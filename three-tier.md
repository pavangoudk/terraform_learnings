Below is a beginner-friendly, step-by-step path to deploy a **three-tier app (front-end + back-end API + database)** on **Azure Kubernetes Service (AKS)**, with **production-oriented YAML patterns** you can copy and adapt. I’ll show a “best practice” production approach (managed database) and a “learning” approach (database inside AKS) so you understand the tradeoffs.

## 0) Target architecture (what you’re building)

**Flow:** User → **Ingress** (entry point) → **Front-end Service** → **Back-end Service** → **Database**

### Key concepts (quick glossary)

- **AKS (Azure Kubernetes Service):** Managed Kubernetes control plane + your worker nodes.
- **Pod:** Smallest deployable unit (your container(s) running together).
- **Deployment:** Runs stateless Pods; supports rolling updates.
- **StatefulSet:** Runs stateful Pods (e.g., database) with stable identity + storage.
- **Service:** Stable internal DNS name + load balancing to Pods.
- **Ingress:** HTTP(S) routing into the cluster (usually with an Ingress Controller like NGINX or Azure Application Gateway).
- **Namespace:** Logical partitioning (e.g., `prod`, `dev`, `apps`).
- **ConfigMap / Secret:** Config and sensitive values injected into Pods.
- **HPA (Horizontal Pod Autoscaler):** Scales Pods based on CPU/memory/metrics.
- **PDB (PodDisruptionBudget):** Prevents too many Pods being evicted during maintenance.
- **RBAC (Role-Based Access Control):** Who can do what in the cluster.
- **NetworkPolicy:** Controls which Pods can talk to which Pods (east-west security).

## 1) Production decision: where should the database run?

### Recommended for production: **Managed database (PaaS)**

Use **Azure Database for PostgreSQL/MySQL** (or Cosmos DB, Azure SQL) with **private networking**. Benefits: backups, patching, HA options, monitoring, easier upgrades.

### OK for learning / limited use: **Database in AKS**

You *can* run PostgreSQL/MySQL in a `StatefulSet`, but production gets harder: backups, upgrades, HA, performance tuning, and data-loss risk if misconfigured.

I’ll provide YAML for both; for real production, prefer managed DB and keep AKS focused on stateless tiers.

## 2) Prereqs (minimal)

- Azure subscription + permission to create resources
- Local tools: `az` (Azure CLI) and `kubectl`
- Container images for:
- `frontend` (e.g., NGINX serving static SPA)
- `backend` (e.g., Node/Java/.NET API)
- `db` (only if you run DB in AKS)

## 3) Step-by-step: create Azure resources (AKS + ACR)

### 3.1 Create resource group, registry, and AKS

Use **Azure Container Registry (ACR)** for private image hosting.

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
# Variables (edit)
RG="rg-3tier-prod"
LOC="eastus"
ACR="acr3tier$RANDOM"
AKS="aks-3tier-prod"

az group create -n "$RG" -l "$LOC"

az acr create -g "$RG" -n "$ACR" --sku Standard

# AKS (baseline). Consider adding private cluster, Azure AD RBAC, and Workload Identity for prod.
az aks create -g "$RG" -n "$AKS" \
  --node-count 3 \
  --enable-managed-identity \
  --attach-acr "$ACR" \
  --enable-oidc-issuer \
  --enable-workload-identity \
  --enable-addons monitoring

az aks get-credentials -g "$RG" -n "$AKS"
```

**Production best practices to apply early (conceptual):**

- Use **separate node pools** (system vs user; optionally GPU or memory-optimized).
- Enable **Azure AD integration** for Kubernetes API access (RBAC).
- Prefer **private cluster** + controlled egress for stricter environments.
- Use **Workload Identity** (OIDC) to access Azure resources without long-lived secrets.

## 4) Step-by-step: Kubernetes “baseline” YAML (namespaces, quotas, network)

Create a dedicated namespace and some safety rails (helps prevent “noisy neighbor” and accidental overuse).

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Namespace
metadata:
  name: apps-prod
  labels:
    # Pod Security Standards (PSS): "restricted" is a strong default for prod.
    pod-security.kubernetes.io/enforce: "restricted"
    pod-security.kubernetes.io/audit: "restricted"
    pod-security.kubernetes.io/warn: "restricted"
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: ResourceQuota
metadata:
  name: apps-prod-quota
  namespace: apps-prod
spec:
  hard:
    requests.cpu: "4"
    requests.memory: 8Gi
    limits.cpu: "8"
    limits.memory: 16Gi
    pods: "50"
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: LimitRange
metadata:
  name: apps-prod-defaults
  namespace: apps-prod
spec:
  limits:
    - type: Container
      defaultRequest:
        cpu: 100m
        memory: 128Mi
      default:
        cpu: 500m
        memory: 512Mi
```

### (Optional but recommended) Default-deny network policy

This blocks all traffic between Pods until you explicitly allow it (very useful for production security).

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: apps-prod
spec:
  podSelector: {}
  policyTypes:
    - Ingress
    - Egress
```

> Note: NetworkPolicy enforcement depends on your AKS networking/CNI setup and policy engine; validate it in your environment before assuming it blocks traffic.

## 5) Step-by-step: configuration and secrets (per environment)

### 5.1 Non-sensitive config via ConfigMap

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: ConfigMap
metadata:
  name: backend-config
  namespace: apps-prod
data:
  ASPNETCORE_ENVIRONMENT: "Production"
  LOG_LEVEL: "Information"
  # Example: backend listens on 8080
  PORT: "8080"
```

### 5.2 Sensitive values via Secret (baseline)

For true production, prefer **Azure Key Vault + Secrets Store CSI Driver** (so secrets aren’t stored in Git). But here’s a simple Kubernetes Secret to illustrate wiring:

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Secret
metadata:
  name: backend-secrets
  namespace: apps-prod
type: Opaque
stringData:
  DB_HOST: "postgres.apps-prod.svc.cluster.local"
  DB_NAME: "appdb"
  DB_USER: "appuser"
  DB_PASSWORD: "REPLACE_ME"
```

## 6) Database tier YAML (two options)

## Option A (recommended): Managed DB outside AKS

In this model, your “database tier YAML” is mostly: (1) a Secret with connection info, and optionally (2) a Service name inside the cluster to standardize DNS.

**Optional `ExternalName` Service** to give an internal DNS alias:

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: apps-prod
spec:
  type: ExternalName
  externalName: "your-managed-postgres-private-fqdn.example.local"
```

You’d keep the actual DB credentials in **Key Vault** (preferred) or a Kubernetes Secret (simpler, less ideal).

## Option B (learning): PostgreSQL inside AKS (StatefulSet)

This is a simplified single-instance example (not HA). For real production HA, you’d typically use a managed DB or a well-designed operator pattern.

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: apps-prod
spec:
  clusterIP: None
  selector:
    app: postgres
  ports:
    - name: postgres
      port: 5432
      targetPort: 5432
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data
  namespace: apps-prod
spec:
  accessModes: ["ReadWriteOnce"]
  resources:
    requests:
      storage: 20Gi
  storageClassName: managed-csi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: apps-prod
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      securityContext:
        fsGroup: 999
      containers:
        - name: postgres
          image: postgres:16
          ports:
            - containerPort: 5432
              name: postgres
          env:
            - name: POSTGRES_DB
              value: appdb
            - name: POSTGRES_USER
              value: appuser
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: backend-secrets
                  key: DB_PASSWORD
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data
          resources:
            requests:
              cpu: 250m
              memory: 512Mi
            limits:
              cpu: "1"
              memory: 1Gi
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 20Gi
        storageClassName: managed-csi
```

## 7) Back-end tier YAML (API)

Includes: Deployment, Service, HPA, PDB. This is where most “production readiness” work happens (probes, resources, security context).

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: apps-prod
  labels:
    app: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      # Strong defaults; ensure your image supports non-root.
      securityContext:
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: backend
          image: YOUR_ACR.azurecr.io/backend:1.0.0
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8080
          envFrom:
            - configMapRef:
                name: backend-config
            - secretRef:
                name: backend-secrets
          readinessProbe:
            httpGet:
              path: /health/ready
              port: http
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health/live
              port: http
            initialDelaySeconds: 20
            periodSeconds: 20
          resources:
            requests:
              cpu: 200m
              memory: 256Mi
            limits:
              cpu: "1"
              memory: 512Mi
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            readOnlyRootFilesystem: true
            capabilities:
              drop: ["ALL"]
          # If your app needs temp space with readOnlyRootFilesystem:
          volumeMounts:
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: tmp
          emptyDir: {}
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: apps-prod
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
    - name: http
      port: 80
      targetPort: 8080
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: backend-hpa
  namespace: apps-prod
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: backend
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: backend-pdb
  namespace: apps-prod
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: backend
```

### Allow only front-end → back-end traffic (if using NetworkPolicy)

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-allow-from-frontend
  namespace: apps-prod
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes: ["Ingress", "Egress"]
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
      ports:
        - protocol: TCP
          port: 8080
  egress:
    - to:
        - podSelector:
            matchLabels:
              app: postgres
      ports:
        - protocol: TCP
          port: 5432
    # Optional: allow DNS to kube-system (adjust for your cluster)
    - to:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: kube-system
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
```

## 8) Front-end tier YAML

Front-end typically serves static content and calls the back-end via internal DNS or through the same Ingress host/path.

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: apps-prod
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      securityContext:
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: frontend
          image: YOUR_ACR.azurecr.io/frontend:1.0.0
          ports:
            - name: http
              containerPort: 8080
          readinessProbe:
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 20
            periodSeconds: 20
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 256Mi
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            readOnlyRootFilesystem: true
            capabilities:
              drop: ["ALL"]
          volumeMounts:
            - name: tmp
              mountPath: /tmp
      volumes:
        - name: tmp
          emptyDir: {}
```

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: apps-prod
spec:
  type: ClusterIP
  selector:
    app: frontend
  ports:
    - name: http
      port: 80
      targetPort: 8080
```

## 9) Expose the app: Ingress + TLS (HTTPS)

You need an **Ingress Controller** installed (common choice: NGINX Ingress; alternative: Azure Application Gateway Ingress). The YAML below assumes class `nginx`. For TLS, reference a Kubernetes TLS Secret (often created by `cert-manager`, or created manually).

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: apps-prod
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - app.example.com
      secretName: app-tls
  rules:
    - host: app.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: frontend
                port:
                  number: 80
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: backend
                port:
                  number: 80
```

**Production best practice:** use TLS end-to-end where required, enforce modern ciphers, and consider WAF (Web Application Firewall) at the edge.

## 10) Deploy order (recommended)

1. Namespace + quota/limits + (optional) default-deny NetworkPolicy
2. ConfigMap + Secret (or Key Vault integration)
3. Database (or validate connectivity to managed DB)
4. Back-end Deployment/Service + HPA + PDB + NetworkPolicy rules
5. Front-end Deployment/Service + (optional HPA/PDB)
6. Ingress + TLS
7. Smoke test + load test + validate scaling + validate failover behavior

Example apply sequence:

```
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl apply -f 00-namespace.yaml
kubectl apply -f 01-quota.yaml
kubectl apply -f 02-limits.yaml
kubectl apply -f 03-configmap.yaml
kubectl apply -f 04-secrets.yaml
kubectl apply -f 10-db.yaml
kubectl apply -f 20-backend.yaml
kubectl apply -f 21-backend-hpa.yaml
kubectl apply -f 22-backend-pdb.yaml
kubectl apply -f 30-frontend.yaml
kubectl apply -f 40-ingress.yaml
```

## 11) Production-readiness checklist (AKS-focused)

### Security

- **Don’t store secrets in Git**: use **Azure Key Vault** + Workload Identity + CSI Driver where possible.
- Enforce **non-root**, **readOnlyRootFilesystem**, **drop ALL capabilities**, and **RuntimeDefault seccomp** (as shown).
- Use **RBAC**: restrict who can `kubectl apply` to prod.
- Use **NetworkPolicy**: explicitly allow only necessary traffic flows.
- Pin images by **version tag** (or digest), avoid `:latest`.
- Scan/sign images (supply chain) and restrict allowed registries if your org requires it.

### Scalability & resilience

- Set **requests/limits** (enables stable scheduling and meaningful autoscaling).
- Add **HPA** for stateless tiers; consider **Cluster Autoscaler** for nodes.
- Add **PDB** for critical services.
- Ensure **readiness probes** reflect true “ready to serve” state (e.g., DB reachable if required).

### Maintenance & operations

- Centralize logs/metrics: **Azure Monitor / Container Insights** (AKS add-on) + app-level structured logs.
- Use **GitOps** (e.g., Flux/Argo) or a CI/CD pipeline to apply YAML consistently.
- Plan upgrades: regular AKS + node image upgrades; test in lower environments first.
- Backups: for managed DB, enable backups/point-in-time restore; for in-cluster DB, design and test backup/restore explicitly.

## 12) Common beginner pitfalls to avoid

- Exposing every Service as `LoadBalancer` (cost + security risk). Prefer **ClusterIP + Ingress**.
- Missing **resource requests/limits** → unpredictable performance and failed autoscaling.
- No **readiness probe** → traffic goes to Pods before the app is ready.
- Keeping secrets in plaintext YAML → accidental leaks.
- Running a database in AKS without a backup/restore plan → high data loss risk.
- No **NetworkPolicy** → any compromised Pod can laterally move in-cluster.
- Mixing dev/test/prod in one namespace without quotas/controls.

## 13) If you want, I can tailor the YAML to your exact app

If you share: (1) front-end and back-end container ports, (2) health endpoints, (3) desired domain name, (4) chosen database type (Postgres/MySQL/etc.), I can produce a clean “apply-ready” set of manifests (or a Kustomize layout) aligned to your needs.
