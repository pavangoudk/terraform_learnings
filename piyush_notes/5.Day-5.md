## Understanding Terraform Variables: Input, Output, and Locals

### Overview üìö
This video offers a practical introduction to variables in Terraform, focusing on **input variables**, **output variables**, and **locals**. It explains how variables help avoid hardcoding values, promote reusability, and manage dynamic configuration more efficiently. The teaching method combines conceptual explanation with hands-on coding demonstrations, emphasizing how to declare, initialize, and utilize each type of variable. The video also clarifies variable type constraints and explores different ways to pass variable values, including their precedence order, making it ideal for beginners aiming to master Terraform variable management.

### Summary of core knowledge points ‚è≥
- **00:00 - 01:51: Introduction to Types of Terraform Variables**  
  Explains three primary variable types: input, output, and locals.  
  - Input variables are user-provided values that parameterize Terraform configurations.  
  - Output variables are values returned or displayed after resource provisioning.  
  - Locals are internally defined variables used to hold values reused within configurations.  
  Discusses type constraints‚Äîprimitive types (string, number, boolean) accept single values; complex types (list, set, map, object, tuple) accept collections. Default type is `any`.

- **01:51 - 05:22: Declaring and Using Input Variables**  
  Demonstrates copying a Terraform file and modifying it to include an input variable named `environment`.  
  - Shows variable block syntax, including type, optional description, and default value.  
  - Emphasizes avoiding hardcoding, allowing centralized value changes that propagate across resources.  
  Example: Tagging various resources in a staging environment by referencing a single variable.

  ```tf
  variable "environment" {
    type = string
    description = "the env type"
    default = "staging" 
  }
  ```

- **05:22 - 07:50: Using Input Variables in Terraform Configuration**  
  Demonstrates referencing variables with `var.<variable_name>` syntax.  
  Walks through running `terraform init` and `terraform plan` commands to initialize the backend and check plans using the declared variables.

- **07:50 - 11:50: Methods to Assign Values to Variables and Precedence**  
  Explains different methods to override default variable values:  
  - Using the `-var` flag on the command line (highest precedence)  
  - Using a `.tfvars` file containing simple key-value pairs  
  - Environment variables prefixed with `TF_VAR_` (lowest precedence)  
  Demonstrates these approaches and explains their precedence order thoroughly, noting environment variables are least preferred and `.tfvars` files override defaults but are overridden by command-line flags.

- **11:50 - 16:11: Output Variables Usage**  
  Describes output variables as a mechanism to print or export useful information after `terraform apply` or `plan`.  
  - Shows syntax combining declaration and assignment in one block.  
  - Example: Outputting the storage account name created by Terraform, referencing attributes generated by the resource (e.g., `azurerm_storage_account.example.name`).  
  - Explains usage of output in chaining modules or as environment variables.
  
  ```tf
  resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "West Europe"
  }

  resource "azurerm_storage_account" "example" {
    name                     = "techtutorial101"
    resource_group_name      = azurerm_resource_group.example.name
    location                 = azurerm_resource_group.example.location # implicit dependency
    account_tier             = "Standard"
    account_replication_type = "LRS"
  
  output "storage_account_name" {
    value = azurerm_storage_account.example.name
  }
  
- **16:11 - 19:40: Locals: Internal Variables for Reusability**  
  Explains locals as variables for values that rarely change and encourage reuse without repeating declarations.  
  - Demonstrates defining a `local` block that groups common tags as a map with keys like `environment`, `lob` (line of business), and `stage`.  
  - Shows accessing individual values within this map using dot notation (`local.common_tags.environment`).  
  - Discusses error from incorrectly using a map where a string is expected, highlighting the need to specify key when referencing complex types.
```tf
  locals {
    common_tags = {
      environment = "dev"
      lob = "banking"
      stage = "alpha"
    }
  }
  
  resource "azurerm_resource_group" "example" {
    name     = "example-resources"
    location = "West Europe"
      tags = {
      environment = local.common_tags.environment
    }
  }
```
- **19:40 - End: Wrap-up and Preview of Next Topic**  
  Summarizes learnings and announces next video will cover best practices for Terraform file structure, naming conventions, and file loading behaviors.

### Key terms and definitions üìù
- **Input Variable**: A parameter defined by the user to customize Terraform configuration; declared with the `variable` keyword.  
- **Output Variable**: A value exported from Terraform after resource creation or modification, helpful for referencing or displaying important attributes.  
- **Local Variable (Locals)**: Internally defined variables limited to a configuration scope, used for reuse and to reduce redundancy.  
- **Type Constraint**: Defines the expected data type for a variable (e.g., `string`, `number`, `bool`, `list`, `map`).  
- **Variable Precedence**: The order in which Terraform prioritizes values assigned to variables: command line `-var` > `.tfvars` files > environment variables (`TF_VAR_`) > defaults.  
- **Terraform Init (`terraform init`)**: Command to initialize a Terraform working directory, downloading required providers and preparing the backend.  
- **Terraform Plan (`terraform plan`)**: Command to show changes Terraform will make based on current configuration and variables.

### Reasoning structure üîç
1. **Premise:** Avoid hardcoding values to enable flexibility in Terraform configurations.  
   ‚Üí **Reasoning:** Define input variables to allow external value passing; use types and defaults for validation and ease.  
   ‚Üí **Conclusion:** Single centralized change propagates to all resources using that variable.

2. **Premise:** Variables can be set from different sources, each with different override priorities.  
   ‚Üí **Reasoning:** Command line `-var` overrides `.tfvars` files and environment variables, enabling quick overrides for secrets or testing.  
   ‚Üí **Conclusion:** Users must understand variable precedence to manage configuration correctly.

3. **Premise:** Some values rarely change and are reused within Terraform.  
   ‚Üí **Reasoning:** Locals provide a way to declare such reusable constants without requiring input or output.  
   ‚Üí **Conclusion:** Locals reduce redundancy and avoid re-declaration without complex passing mechanisms.

### Examples üéì
- **Tagging environment variable for multiple resources**: Instead of hardcoding `staging` multiple times in resource blocks, an input variable `environment` is declared and referenced as `var.environment`. This ensures changing the environment tag in one place updates all resource tags, demonstrating efficiency and error reduction.

- **Outputting storage account name**: After creating a storage account resource, an output variable is defined to print the storage account‚Äôs name (`azurerm_storage_account.example.name`). This illustrates how outputs expose resource attributes for later use or display.

- **Local map for common tags**: A local variable called `common_tags` is defined as a map with keys like `environment`, `lob`, and `stage`. This map is then used to reference tags individually, showing how locals simplify reusing grouped data.

### Error-prone points ‚ö†Ô∏è
- **Misunderstanding variable precedence:** Some users expect environment variables to override other methods, but Terraform assigns them the lowest precedence. The command-line `-var` flag always has the highest priority.  
- **Incorrect reference of complex data types:** Referencing a map or object without specifying the key (e.g., using `local.common_tags` instead of `local.common_tags.environment`) can cause type errors, as Terraform expects a single scalar value where needed.  
- **Hardcoding values instead of using variables:** Reduces flexibility and increases risk of inconsistencies across multiple resource definitions.

### Quick review tips/self-test exercises üß†
- **Tips (no answers):**  
  - How do input variables improve Terraform configuration management?  
  - What is the difference between input and output variables?  
  - What are the possible ways to assign values to Terraform variables?  
  - Explain the concept of variable precedence in Terraform.  
  - When should you use locals instead of input variables?

- **Exercises (with answers):**  
  1. *Q:* Define an input variable `project_name` of type string with default value `demo`.  
     *A:*  
     ```hcl
     variable project_name {
       type        = string
       default     = demo
       description = Project name for resources
     }
     ```
  2. *Q:* Write an output variable that shows the ID of an AWS instance named `my_instance`.  
     *A:*  
     ```hcl
     output instance_id {
       value = aws_instance.my_instance.id
     }
     ```
  3. *Q:* In what order does Terraform resolve variable values when given defaults, `.tfvars` file, environment variable, and CLI flag?  
     *A:* Defaults < Environment Variable (`TF_VAR_`) < `.tfvars` file < CLI `-var` flag (highest).

### Summary and review üîÑ
This lesson covered foundational aspects of Terraform variable management by detailing input variables for parameterizing configurations, output variables to extract resource attributes post-provisioning, and locals for internal reuse of constant or grouped values. It emphasized the importance of type constraints, avoiding hardcoding, and demonstrated multiple practical methods to assign variable values, highlighting their precedence to enable predictable overrides. These variable mechanisms collectively enable dynamic, scalable, and maintainable infrastructure as code, setting a strong base for learning advanced Terraform practices like modularization and secret management.
