Code Generated by Sidekick is for learning and experimentation purposes only. For other use cases, please see the guidance linked here for accessing and using the Deloitte-approved tools [GitHub Copilot](https://resources.deloitte.com/:p:/r/sites/MyTechnology/GenAI/Platforms_Tools/GitHub%20Copilot/GitHub_Copilot_Overview_Guide.pptx?d=w5099365971a946aaa49908583395b585&csf=1&web=1&e=I1r8Pf) or [AWS Codewhisperer](https://resources.deloitte.com/:p:/r/sites/MyTechnology/_layouts/15/Doc.aspx?sourcedoc=%7b5FA15CB2-2328-460F-8220-DC996136BAC5%7d&file=Amazon_CodeWhisperer_Overview_Guide.pptx&action=edit&mobileredirect=true).

Below is a practical “build-to-run” guide for a **three-tier .NET app on Azure Kubernetes Service (AKS)**, with **YAML you can copy per tier**, plus scaling/update/security patterns that work well for real deployments.

## 0) Target architecture (simple + production-friendly)

**Tiers**

1. **Web/Presentation tier**: .NET ([ASP.NET](http://asp.net/) Core UI/BFF) behind **Ingress** (HTTPS).
2. **Application/API tier**: .NET API + worker services (internal-only service).
3. **Data tier (recommended)**: **Azure SQL Database** (or Azure Database for PostgreSQL, etc.) **outside** the cluster.
- You *can* run a database in AKS, but it’s usually more operational risk (backups, patching, failover, storage tuning). For most three-tier enterprise apps, **managed DB** is the best practice.

**Core AKS building blocks**

- **Namespaces** per environment (`dev`, `test`, `prod`) or per app.
- **Deployments** for stateless tiers (web/API).
- **Services** for stable networking (ClusterIP internally; Ingress externally).
- **Ingress Controller** (NGINX Ingress or Application Gateway Ingress Controller).
- **Horizontal Pod Autoscaler (HPA)** for scaling pods.
- **Cluster Autoscaler** for scaling nodes.
- **Key Vault + Workload Identity** for secrets (avoid plain Kubernetes Secrets where possible).
- **Azure Monitor / Container Insights** for logs/metrics.

## 1) Prerequisites and “early decisions” (avoid rework)

### Tools you’ll use locally

- Azure CLI, kubectl
- Docker (or build service)
- Optional: Helm or Kustomize (for packaging YAML)

### Decide these upfront

- **Ingress**: NGINX Ingress (simple) vs **Application Gateway** (tighter Azure integration). This guide uses **NGINX Ingress** for clarity.
- **Networking**:
- **Azure CNI** (pods get VNet IPs; common for enterprise networking).
- Consider **private AKS** for stricter security (adds complexity).
- **Identity**: Use **Microsoft Entra ID (Azure AD)–integrated AKS** + **Workload Identity** for pod-to-Azure auth.
- **Container registry**: Azure Container Registry (ACR).

## 2) Create Azure resources (RG, ACR, AKS) — step-by-step

> Replace bracketed values.

### 2.1 Variables (optional)

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
export LOCATION=eastus
export RG=rg-aks-3tier
export ACR_NAME=acr3tier$RANDOM
export AKS_NAME=aks-3tier
export DNS_LABEL=three-tier-demo
```

### 2.2 Create Resource Group and ACR

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
az group create -n $RG -l $LOCATION

az acr create -g $RG -n $ACR_NAME --sku Standard
```

### 2.3 Create AKS (Entra ID integration, OIDC/workload identity, autoscaling)

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
az aks create -g $RG -n $AKS_NAME \
  --enable-aad \
  --enable-oidc-issuer \
  --enable-workload-identity \
  --attach-acr $ACR_NAME \
  --node-count 3 \
  --enable-cluster-autoscaler --min-count 3 --max-count 8 \
  --network-plugin azure \
  --generate-ssh-keys
```

### 2.4 Get kubeconfig

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
az aks get-credentials -g $RG -n $AKS_NAME
kubectl get nodes
```

## 3) Install cluster add-ons (ingress, monitoring)

### 3.1 Install NGINX Ingress Controller

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl create namespace ingress-nginx

kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.0/deploy/static/provider/cloud/deploy.yaml
```

> If your environment blocks direct applies, use Helm or vendor the manifests internally.

### 3.2 Enable monitoring (recommended)

Use **Azure Monitor / Container Insights** in your AKS settings (portal) or via CLI (varies by setup). At minimum, plan for:

- centralized logs
- container metrics
- alerts on CPU/memory, restarts, 5xx rate, latency

## 4) Build & push container images (web and api tiers)

Assume you have two projects:

- `src/Web/Web.csproj`
- `src/Api/Api.csproj`

### 4.1 Build and push (example)

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
az acr login -n $ACR_NAME

export ACR_LOGIN_SERVER=$(az acr show -n $ACR_NAME --query loginServer -o tsv)
export TAG=1.0.0

docker build -t $ACR_LOGIN_SERVER/web:$TAG -f src/Web/Dockerfile .
docker build -t $ACR_LOGIN_SERVER/api:$TAG -f src/Api/Dockerfile .

docker push $ACR_LOGIN_SERVER/web:$TAG
docker push $ACR_LOGIN_SERVER/api:$TAG
```

**Best practices**

- Use non-root images when possible.
- Set resource requests/limits.
- Add `/health` endpoints for readiness/liveness probes.
- Keep config external (ConfigMap/Key Vault).

## 5) YAML layout (one file per concern, easy to reason about)

Create a folder like:

- `00-namespace.yaml`
- `01-config.yaml`
- `02-api.yaml`
- `03-web.yaml`
- `04-ingress.yaml`
- `05-hpa.yaml`
- `06-networkpolicy.yaml`
- `07-pdb.yaml`
- (optional) `08-resourcequota.yaml`

Apply in order:

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl apply -f 00-namespace.yaml
kubectl apply -f 01-config.yaml
kubectl apply -f 02-api.yaml
kubectl apply -f 03-web.yaml
kubectl apply -f 04-ingress.yaml
kubectl apply -f 05-hpa.yaml
kubectl apply -f 06-networkpolicy.yaml
kubectl apply -f 07-pdb.yaml
```

## 6) Tier setup details + YAML examples

### 6.1 Namespace (isolate and scope policies)

**00-namespace.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: Namespace
metadata:
  name: three-tier
  labels:
    name: three-tier
```

### 6.2 Shared config (ConfigMap) + placeholder Secret strategy

**Recommended**: store secrets in **Azure Key Vault** and mount/inject via CSI driver + Workload Identity.

**Simpler starting point**: Kubernetes Secret (works, but you must secure etcd and RBAC carefully).

**01-config.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: three-tier
data:
  ASPNETCORE_ENVIRONMENT: "Production"
  Api__BaseUrl: "http://api.three-tier.svc.cluster.local"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-conn
  namespace: three-tier
type: Opaque
stringData:
  ConnectionStrings__DefaultConnection: "Server=tcp:YOURSQL.database.windows.net,1433;Database=YOURDB;User ID=YOURUSER;Password=YOURPASSWORD;Encrypt=True;"
```

> Move that connection string to Key Vault as soon as you can; treat this Secret approach as a bootstrap only.

### 6.3 Application/API tier (internal service)

**02-api.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  namespace: three-tier
spec:
  replicas: 2
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      securityContext:
        runAsNonRoot: true
      containers:
        - name: api
          image: YOUR_ACR_LOGIN_SERVER/api:1.0.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          envFrom:
            - configMapRef:
                name: app-config
            - secretRef:
                name: db-conn
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health/live
              port: 8080
            initialDelaySeconds: 20
            periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: api
  namespace: three-tier
spec:
  selector:
    app: api
  ports:
    - name: http
      port: 80
      targetPort: 8080
  type: ClusterIP
```

**Integration notes**

- Web tier calls `http://api` (cluster DNS).
- Add retry/timeouts in HttpClient; don’t rely on infinite defaults.
- Consider **pod anti-affinity** for higher availability across nodes.

### 6.4 Web/Presentation tier (served externally via Ingress)

**03-web.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: three-tier
spec:
  replicas: 2
  revisionHistoryLimit: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      securityContext:
        runAsNonRoot: true
      containers:
        - name: web
          image: YOUR_ACR_LOGIN_SERVER/web:1.0.0
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          envFrom:
            - configMapRef:
                name: app-config
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          readinessProbe:
            httpGet:
              path: /health/ready
              port: 8080
            initialDelaySeconds: 10
          livenessProbe:
            httpGet:
              path: /health/live
              port: 8080
            initialDelaySeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: web
  namespace: three-tier
spec:
  selector:
    app: web
  ports:
    - name: http
      port: 80
      targetPort: 8080
  type: ClusterIP
```

### 6.5 Ingress (route external traffic to web)

**04-ingress.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
  namespace: three-tier
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  rules:
    - host: YOUR_APP_DNS_NAME
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  number: 80
# For HTTPS, add a tls: section and a Secret with certs (often via cert-manager).
```

Get the public IP for ingress and map DNS to it:

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl -n ingress-nginx get svc ingress-nginx-controller
```

## 7) Scaling scenarios (pods and nodes)

### 7.1 Pod autoscaling with HPA (typical for web/api)

**05-hpa.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-hpa
  namespace: three-tier
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
  namespace: three-tier
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60
```

Operate it:

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl -n three-tier get hpa
kubectl -n three-tier top pods
```

### 7.2 Node scaling (Cluster Autoscaler)

You enabled it at cluster create time. It adds/removes nodes based on pending pods and constraints. Best practices:

- Separate **system** and **user** node pools.
- Use **taints/tolerations** if you add specialized pools (e.g., “cpu-optimized” vs “general”).

## 8) Updates and release management (safe rollouts)

### 8.1 Rolling update (built-in)

Update the image and watch rollout:

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl -n three-tier set image deployment/web web=YOUR_ACR_LOGIN_SERVER/web:1.0.1
kubectl -n three-tier rollout status deployment/web

kubectl -n three-tier set image deployment/api api=YOUR_ACR_LOGIN_SERVER/api:1.0.1
kubectl -n three-tier rollout status deployment/api
```

Rollback if needed:

```bash
Bash# Code Generated by Sidekick is for learning and experimentation purposes only.
kubectl -n three-tier rollout undo deployment/web
kubectl -n three-tier rollout undo deployment/api
```

### 8.2 More controlled releases (common “next step”)

- **Blue/Green** or **Canary** using a progressive delivery controller (e.g., Argo Rollouts) and metric-based promotion.
- Use a CI/CD pipeline to:
1. build + scan image
2. push to ACR
3. deploy via Helm/Kustomize
4. run smoke tests against Ingress

## 9) Security and resource-management best practices (AKS-focused)

### 9.1 Identity and access

- **Entra ID–integrated AKS** + Kubernetes RBAC.
- Use **least privilege**: separate admin and developer roles; namespace-scoped permissions.
- Prefer **Workload Identity** for pods accessing Azure (Key Vault, Storage, etc.).

### 9.2 Secrets and configuration

- Best practice: **Azure Key Vault** + CSI secrets store driver (avoid embedding secrets in YAML).
- Rotate secrets; don’t put secrets in container images or ConfigMaps.

### 9.3 Network security

- Use **Network Policies** to restrict traffic (deny-by-default is ideal once stable).
- Keep API tier internal (ClusterIP only) and expose only web via Ingress.
- Consider **private cluster**, private endpoints for PaaS DB, and controlled egress.

**06-networkpolicy.yaml (starter example)**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: three-tier
spec:
  podSelector: {}
  policyTypes:
    - Ingress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-web-to-api
  namespace: three-tier
spec:
  podSelector:
    matchLabels:
      app: api
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: web
      ports:
        - protocol: TCP
          port: 8080
```

> You may need your cluster networking configured to enforce network policies (implementation-dependent).

### 9.4 Pod/container hardening

- Run as non-root, drop Linux capabilities where possible.
- Avoid privileged containers and hostPath mounts.
- Use **readiness/liveness** probes (already shown).
- Use **resource requests/limits** (already shown) to stabilize scheduling.

### 9.5 Availability and disruption control

**07-pdb.yaml**

```yaml
YAML# Code Generated by Sidekick is for learning and experimentation purposes only.
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: web-pdb
  namespace: three-tier
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: web
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: api-pdb
  namespace: three-tier
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: api
```

### 9.6 Resource governance (helpful once multiple teams share AKS)

Add **ResourceQuota** and **LimitRange** per namespace to prevent “noisy neighbor” incidents.

## 10) Data tier: recommended approach (Azure SQL) + integration

**Recommended pattern**

- Azure SQL is provisioned in Azure.
- Your API reads the connection string from **Key Vault** (ideal) or Kubernetes Secret (bootstrap).
- Lock down access with:
- Private networking (private endpoint) when feasible
- Firewall rules scoped to egress
- Managed identity / Entra auth when possible (app pattern dependent)

If you want, I can provide a **Key Vault + Workload Identity** example (ServiceAccount + federated identity + SecretProviderClass YAML) tailored to your subscription and naming conventions.

## 11) Day-2 operations checklist (what keeps AKS stable)

- **Observability**: dashboards for CPU/memory, request rate, latency, error rate; log search for exceptions.
- **Alerts**: pod crash loops, HPA maxed, node pressure, ingress 5xx spikes.
- **Upgrades**: upgrade node pools in a controlled window; keep `revisionHistoryLimit`; use PDBs.
- **Cost controls**: cluster autoscaler bounds; right-size requests; separate non-prod clusters.
- **Security posture**: image scanning, policy enforcement, RBAC reviews, secret rotation.
