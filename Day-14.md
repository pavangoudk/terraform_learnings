## Azure Terraform Mini Project: Building a Scalable Web Application Infrastructure

### Overview üìö
This video introduces a hands-on mini project for deploying an application infrastructure in Azure using Terraform. It emphasizes creating a scalable and secure environment by building multiple interconnected resources such as virtual machines, load balancers, network security groups, and gateways. The instructor walks through the architecture design, resource configuration, and automation with Terraform scripts, aiming to provide practical skills to manage infrastructure as code while setting assignments to deepen learning. Core focus areas include network segmentation with subnets, load balancing across virtual machine scale sets, secure access with NSG rules, and autoscaling based on CPU utilization.

### Summary of Core Knowledge Points ‚è±Ô∏è

- **00:00 - 02:00 | Project Introduction & Architecture Overview**
  - Outline of the mini project that deploys a web-based game application.
  - Architecture involves resource group creation, a virtual network encapsulating all resources.
  - Emphasis on using virtual machine scale sets (VMSS), load balancer, public IP, network security group (NSG), and gateway.
  - Importance of resource segmentation inside a subnet for security and management.

  ```tf
  # Code Generated by Sidekick is for learning and experimentation purposes only.
  provider "azurerm" {
    features {}
  }
  
  resource "azurerm_resource_group" "rg" {
    name     = "rg-gameapp"
    location = "East US"
  }

  ```
  
- **02:00 - 05:00 | Virtual Network and Subnet Planning**
  - Creation of virtual network (VNet) with address space (10.0.0.0/16) that supports ~65,000 IPs.
  - Subnets created to isolate resources and control network traffic.
  - NSG rules applied to subnets to restrict access‚Äîfor example, allowing only certain ports like 80 or 443 for frontend and more restricted access for backend.

  ```tf
  resource "azurerm_virtual_network" "vnet" {
    name                = "vnet-gameapp"
    address_space       = ["10.0.0.0/16"]
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
  }
  
  resource "azurerm_subnet" "frontend" {
    name                 = "frontend"
    resource_group_name  = azurerm_resource_group.rg.name
    virtual_network_name = azurerm_virtual_network.vnet.name
    address_prefixes     = ["10.0.1.0/24"]
  }
  
  resource "azurerm_network_security_group" "frontend_nsg" {
    name                = "frontend-nsg"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
  
    security_rule {
      name                       = "allow-http"
      priority                   = 100
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "80"
      source_address_prefix      = "*"
      destination_address_prefix = "*"
    }
  
    security_rule {
      name                       = "allow-https"
      priority                   = 110
      direction                  = "Inbound"
      access                     = "Allow"
      protocol                   = "Tcp"
      source_port_range          = "*"
      destination_port_range     = "443"
      source_address_prefix      = "*"
      destination_address_prefix = "*"
    }
  }
  
  resource "azurerm_subnet_network_security_group_association" "frontend_assoc" {
    subnet_id                 = azurerm_subnet.frontend.id
    network_security_group_id = azurerm_network_security_group.frontend_nsg.id
  }

  ```
  
- **05:00 - 07:30 | Load Balancer Configuration and Traffic Flow**
  - Load balancer placed in front with a public IP to receive internet traffic.
  - Backend pool consists of VM instances in VMSS, enabling traffic distribution.
  - Health probes (probes) on port 80 to monitor VM health and route requests only to healthy instances.
  - This ensures high availability and load distribution.

  ```tf
  resource "azurerm_public_ip" "lb" {
    name                = "lb-public-ip"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
    allocation_method   = "Static"
    sku                 = "Standard"
  }
  
  resource "azurerm_lb" "main" {
    name                = "gameapp-lb"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
    sku                 = "Standard"
  
    frontend_ip_configuration {
      name                 = "PublicIPAddress"
      public_ip_address_id = azurerm_public_ip.lb.id
    }
  }
  
  resource "azurerm_lb_backend_address_pool" "bepool" {
    name                = "BackendPool"
    loadbalancer_id     = azurerm_lb.main.id
    resource_group_name = azurerm_resource_group.rg.name
  }
  
  resource "azurerm_lb_probe" "http_probe" {
    resource_group_name = azurerm_resource_group.rg.name
    loadbalancer_id     = azurerm_lb.main.id
    name                = "http-probe"
    protocol            = "Http"
    port                = 80
    request_path        = "/"
  }
  
  resource "azurerm_lb_rule" "http" {
    resource_group_name            = azurerm_resource_group.rg.name
    loadbalancer_id                = azurerm_lb.main.id
    name                           = "http"
    protocol                       = "Tcp"
    frontend_port                  = 80
    backend_port                   = 80
    frontend_ip_configuration_name = "PublicIPAddress"
    backend_address_pool_id        = azurerm_lb_backend_address_pool.bepool.id
    probe_id                       = azurerm_lb_probe.http_probe.id
  }

  ```
- **07:30 - 10:15 | NSG, Gateway, and Security Considerations**
  - Network Security Groups (NSGs) used to allow traffic only from the load balancer, denying external direct access to VMs.
  - Outbound internet access for VMSS instances handled by a NAT gateway, enabling safe patch updates without exposing VMs directly.

  ```tf
    # Code Generated by Sidekick is for learning and experimentation purposes only.
  resource "azurerm_public_ip" "nat" {
    name                = "nat-public-ip"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
    allocation_method   = "Static"
    sku                 = "Standard"
  }
  
  resource "azurerm_nat_gateway" "natgw" {
    name                = "gameapp-natgw"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
  
    sku_name            = "Standard"
  
    public_ip_address_ids = [azurerm_public_ip.nat.id]
  }
  
  resource "azurerm_subnet_nat_gateway_association" "frontend_nat_assoc" {
    subnet_id      = azurerm_subnet.frontend.id
    nat_gateway_id = azurerm_nat_gateway.natgw.id
  }
  
  ```
  
- **10:15 - 14:00 | Autoscaling Rules for VMSS**
  - Autoscaling configured with minimum, default, and maximum VM counts.
  - Scale out triggered when average CPU utilization exceeds 80% for 5 minutes.
  - Scale in triggered when average CPU utilization drops below 10% for 5 minutes.
  - This dynamically adjusts resources according to demand.

  ```tf
        # Code Generated by Sidekick is for learning and experimentation purposes only.
  resource "azurerm_linux_virtual_machine_scale_set" "vmss" {
    name                = "gameapp-vmss"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
    sku                 = "Standard_B2ms"
    instances           = 2
    admin_username      = "azureuser"
    disable_password_authentication = true
  
    ssh_keys {
      path     = "/home/azureuser/.ssh/authorized_keys"
      key_data = file("~/.ssh/id_rsa.pub")
    }
  
    source_image_reference {
      publisher = "Canonical"
      offer     = "UbuntuServer"
      sku       = "18.04-LTS"
      version   = "latest"
    }
  
    upgrade_mode = "Automatic"
  
    network_interface {
      name    = "vmss-nic"
      primary = true
  
      ip_configuration {
        name                                   = "ipconfig"
        subnet_id                              = azurerm_subnet.frontend.id
        load_balancer_backend_address_pool_ids  = [azurerm_lb_backend_address_pool.bepool.id]
        primary                                = true
      }
    }
  
    os_disk {
      caching              = "ReadWrite"
      storage_account_type = "Standard_LRS"
    }
  
    custom_data = base64encode(<<EOF
  #!/bin/bash
  apt-get update
  apt-get install -y apache2 php
  cd /var/www/html
  echo "<?php echo 'Hello from VMSS instance: ' . gethostname(); ?>" > index.php
  systemctl restart apache2
  EOF
    )
  }
  
  resource "azurerm_monitor_autoscale_setting" "vmss_autoscale" {
    name                = "vmss-autoscale"
    location            = azurerm_resource_group.rg.location
    resource_group_name = azurerm_resource_group.rg.name
    target_resource_id  = azurerm_linux_virtual_machine_scale_set.vmss.id
  
    profile {
      name = "autoscale"
      capacity {
        minimum = 1
        default = 2
        maximum = 5
      }

    rule {
      metric_trigger {
        metric_name        = "Percentage CPU"
        metric_resource_id = azurerm_linux_virtual_machine_scale_set.vmss.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "GreaterThan"
        threshold          = 80
      }
      scale_action {
        direction = "Increase"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT5M"
      }
    }
    rule {
      metric_trigger {
        metric_name        = "Percentage CPU"
        metric_resource_id = azurerm_linux_virtual_machine_scale_set.vmss.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "LessThan"
        threshold          = 10
      }
      scale_action {
        direction = "Decrease"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT5M"
      }
    }
  }
  }

  ```

- **14:00 - 17:00 | Project Assignments & Best Practices**
  - Tasks assigned include creating refined NSG rules to restrict access and implementing autoscaling policies.
  - Use of Terraform functions like `lookup`, `concat`, `locals`, and dynamic blocks encouraged for efficient code.
  - Use of tagging with timestamps for resource management emphasized.
  
- **17:00 - 26:00 | Detailed Terraform Configuration Explanation**
  - Breakdown of Terraform resource declarations for Resource Group, Virtual Network, Subnet, NSG and its association.
  - Creation of load balancer with public IP, frontend IP configuration, backend address pool, and load balancer rules.
  - Explanation of dependencies among resources to ensure proper provisioning order.
  - Creation of NAT gateway with public IP for outbound connectivity.
  - VMSS configuration involving image references, network interfaces, VM instance count, availability zones, and custom user data scripts.
  - User data script runs on VM startup to install Apache, PHP, deploy a simple web application.
  - Use of SSH key pairs for secure access.
  - Lifecycle rules to prevent unnecessary VMSS recreation on instance updates.
  
- **26:00 - 31:00 | Deployment and Testing**
  - Terraform plan and apply commands demonstrate resource provisioning.
  - Verification of resources via Azure portal.
  - Testing load balancer public IP displays the deployed game, with load balancing evident by requests hitting different VM instances.
  - Highlighting potential security enhancements like adding SSL/TLS termination.

- **31:00 - 33:55 | Project Wrap-up & Future Work**
  - Reminder to clean up resources to avoid charges.
  - Preview of upcoming projects covering more advanced topics like multiple VNets and VNet peering.
  - Encouragement for continuous learning with additional mini projects targeting specific Azure services.

### Key Terms and Definitions üîë

- **Resource Group**: A container in Azure to hold related resources for management.
- **Virtual Network (VNet)**: Isolated network in Azure that enables communication between resources.
- **Subnet**: Subdivision of a VNet to segment traffic and apply security controls.
- **Network Security Group (NSG)**: A set of firewall rules to control inbound and outbound traffic at subnet or NIC level.
- **Virtual Machine Scale Set (VMSS)**: A group of identical VMs that automatically scale based on demand.
- **Load Balancer**: Distributes incoming network traffic across multiple backend resources.
- **Health Probe**: Checks the status of backend VMs to ensure traffic is directed only to healthy instances.
- **Public IP Address**: An IP address accessible from the internet for resources like load balancers.
- **NAT Gateway**: Provides outbound internet connectivity for VMs without exposing them to inbound internet traffic.
- **User Data Script**: Initialization script run on VM boot to configure environment or deploy apps.
- **Terraform Provider**: Plugin used by Terraform to interact with cloud services.
- **Backend Pool**: Collection of resources that receive traffic from the load balancer.
- **Autoscaling**: Automatic adjustment of resource count based on predefined metrics like CPU.

### Reasoning Structure üîç

1. **Premise**: Need to host an application that is scalable, available, and secure in Azure.
2. **Reasoning**:
   - Use Terraform for infrastructure as code to automate deployment.
   - Encapsulate resources in a Resource Group for easy management.
   - Create a VNet to isolate network traffic.
   - Split VNet into subnets to segregate frontend and backend traffic.
   - Attach NSG rules per subnet to control access based on source and ports.
   - Deploy VMSS for scalable compute instances.
   - Place a load balancer with public IP in front for external access.
   - Use health probes to only route to healthy instances.
   - Attach NAT gateway for outbound internet access securely.
   - Configure autoscaling rules based on CPU thresholds to optimize resource usage.
3. **Conclusion**: This design ensures a manageable, secure, scalable web application setup with automated deployment.

### Examples üéÆ

- **Game Application Deployment**
  - A simple web game is deployed on VM instances via a user data script.
  - Load balancer distributes player requests dynamically across VMSS instances.
  - Refreshing the page shows traffic routing to different VMs, demonstrating successful load balancing.
- **Subnet Access Control**
  - NSG example setting which restricts HTTP and SSH traffic only to specific sources: load balancer and admin IPs.
- **Autoscaling Trigger**
  - When CPU utilization goes above 80% for 5 minutes, scale out happens.
  - When CPU utilization drops below 10% for 5 minutes, scale in triggers, conserving resources.

### Error-prone Points ‚ö†Ô∏è

- **Misunderstanding NSG Rules**: Allowing overly broad inbound access instead of restricting traffic only from load balancer leads to security issues.  
  *Correct:* NSG should allow inbound traffic only from load balancer IP, blocking all other direct access to VMs.

- **Incorrect IP Address Space Calculation:** Misconfiguring subnet CIDRs overlapping or insufficiently sized subnets could cause provisioning failures.  
  *Correct:* Follow CIDR calculations and maintain subnet sizes according to resource needs.

- **Forgetting User Data Script Encoding:** User data must be base64 encoded before assigning to VMSS.  
  *Correct:* Use Terraform's `base64encode()` function to encode user data script.

- **Ignoring Terraform Resource Dependencies:** Creating resources in wrong order disrupts deployments.  
  *Correct:* Use implicit or explicit dependencies in Terraform to enforce correct creation sequence.

- **Not Destroying Resources After Testing:** Leads to unnecessary cloud charges.  
  *Correct:* Always run `terraform destroy` to remove resources once done.

### Quick Review Tips / Self-Test Exercises ‚úçÔ∏è

**Tips (No Answers):**  
- What is the purpose of a Network Security Group in Azure?  
- How does a load balancer determine which backend VM to route traffic to?  
- Explain how autoscaling triggers work based on CPU utilization.  
- Why is a NAT gateway used in this infrastructure?  
- What is the function of the user data script in VMSS deployment?  

**Exercises (With Answers):**  
1. _Q:_ What resource groups contain, and why are they important?  
   _A:_ Resource groups are logical containers that hold and manage related Azure resources collectively for easier lifecycle management.

2. _Q:_ Define a health probe in load balancing.  
   _A:_ A health probe periodically checks backend VM health on a specific port; only healthy VMs receive traffic.

3. _Q:_ How do you restrict SSH access to VMs so only specific IPs can connect?  
   _A:_ Configure NSG rules to allow SSH port (22) only from trusted IP addresses or subnet ranges.

4. _Q:_ What Terraform function is used to encode scripts before passing them to VM instances?  
   _A:_ `base64encode()`

### Summary and Review üîÑ

This video provided a comprehensive walkthrough of deploying a scalable, secure web application environment in Azure using Terraform. It covered key infrastructure components including resource groups, virtual networks and subnets, VM scale sets, load balancers, network security groups, NAT gateways, and autoscaling policies. You learned how to organize resources, configure network access rules, automate application deployments with user data scripts, and apply Terraform best practices like managing dependencies and state files through remote backends. Assignments included tightening security with refined NSG rules and creating autoscaling logic. The project concluded with a practical test of load balancer functionality distributing traffic among VM instances hosting a fun web game, demonstrating a complete end-to-end deployment. The foundational skills gained from this mini project will guide you in efficiently managing cloud infrastructure as code in real-world scenarios.
